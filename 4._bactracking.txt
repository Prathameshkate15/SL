# Backtracking
def is_safe(board, r, c, n):
    # Check left side of row
    for i in range(c):
        if board[r][i]:
            return False

    # Check upper-left diagonal
    i, j = r, c
    while i >= 0 and j >= 0:
        if board[i][j]:
            return False
        i -= 1
        j -= 1

    # Check lower-left diagonal
    i, j = r, c
    while i < n and j >= 0:
        if board[i][j]:
            return False
        i += 1
        j -= 1

    return True


def solve_bt(board, c, n):
    if c == n:
        return True
    for r in range(n):
        if is_safe(board, r, c, n):
            board[r][c] = 1
            if solve_bt(board, c + 1, n):
                return True
            board[r][c] = 0
    return False


# Branch & Bound
def solve_bb(n):
    col = [0] * n
    ld = [0] * (2 * n)
    rd = [0] * (2 * n)
    board = [[0] * n for _ in range(n)]

    def solve(c):
        if c == n:
            return True
        for r in range(n):
            if not col[r] and not ld[r - c + n - 1] and not rd[r + c]:
                board[r][c] = 1
                col[r] = ld[r - c + n - 1] = rd[r + c] = 1
                if solve(c + 1):
                    return True
                board[r][c] = 0
                col[r] = ld[r - c + n - 1] = rd[r + c] = 0
        return False

    solve(0)
    return board


# Run Example
n = 4
board1 = [[0] * n for _ in range(n)]
solve_bt(board1, 0, n)
print("Backtracking:")
for r in board1:
    print(r)

board2 = solve_bb(n)
print("\nBranch & Bound:")
for r in board2:
    print(r)

